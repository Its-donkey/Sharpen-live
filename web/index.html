<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Sharpen.Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header class="surface site-header">
      <div class="logo-lockup">
        <div class="logo-icon" aria-hidden="true">
          <svg viewBox="0 0 120 120" role="img" aria-labelledby="sharpen-logo-title">
            <title id="sharpen-logo-title">Sharpen Live logo</title>
            <defs>
              <linearGradient id="bladeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#f8fafc" stop-opacity="0.95"></stop>
                <stop offset="55%" stop-color="#cbd5f5" stop-opacity="0.85"></stop>
                <stop offset="100%" stop-color="#7dd3fc" stop-opacity="0.95"></stop>
              </linearGradient>
            </defs>
            <path
              d="M14 68c12-20 38-54 80-58l6 36c-12 6-26 14-41 26l-45-4z"
              fill="url(#bladeGradient)"
              stroke="#0f172a"
              stroke-width="4"
              stroke-linecap="round"
              stroke-linejoin="round"
            ></path>
            <path
              d="M19 76l35 4c-5 5-10 11-15 18l-26-8 6-14z"
              fill="rgba(15, 23, 42, 0.45)"
              stroke="#0f172a"
              stroke-width="3.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            ></path>
            <circle cx="32" cy="92" r="6" fill="#38bdf8"></circle>
            <circle cx="88" cy="36" r="6" fill="#38bdf8"></circle>
          </svg>
        </div>
        <div class="logo-text">
          <h1>Sharpen.Live</h1>
          <p>Streaming Knife Craftsmen</p>
        </div>
      </div>
      <a class="cta" href="#streamers">Become a Partner</a>
    </header>

    <main class="surface" id="streamers" aria-labelledby="streamers-title">
      <section class="intro">
        <h2 id="streamers-title" style="margin: 0 0 1rem; font-size: clamp(1.8rem, 2vw + 1rem, 2.4rem); font-family: var(--font-heading);">
          Live Knife Sharpening Studio
        </h2>
        <p style="margin: 0; color: var(--fg-muted); max-width: 720px; line-height: 1.7;">
          Discover bladesmiths and sharpening artists streaming in real time. Status indicators
          show who is live, who is prepping off camera, and who is offline. Premium partners share
          their booking links so you can send in your knives for a professional edge.
        </p>
      </section>

      <section class="streamer-table" aria-label="Sharpen Live streamer roster">
        <table>
          <thead>
            <tr>
              <th scope="col">Status</th>
              <th scope="col">Name</th>
              <th scope="col">Streaming Platforms</th>
              <th scope="col">Language</th>
            </tr>
          </thead>
          <tbody id="streamers-table-body"></tbody>
        </table>
      </section>

      <section class="submit-streamer" aria-labelledby="submit-streamer-title">
        <div class="submit-streamer-header">
          <h2 id="submit-streamer-title">Know a streamer we should feature?</h2>
          <button type="button" class="submit-streamer-toggle" data-submit-streamer-toggle>
            Submit a streamer
          </button>
        </div>

        <form id="submit-streamer-form" class="submit-streamer-form" data-streamer-form hidden>
          <p class="submit-streamer-help">
            Share the details below and we&rsquo;ll open a pull request adding the streamer to the
            roster. You&rsquo;ll need a GitHub token with <code>repo</code> scope or a fine-grained
            token that can read and write to this repository.
          </p>

          <div class="form-grid">
            <label class="form-field">
              <span>Streamer name *</span>
              <input type="text" name="streamer-name" required />
            </label>

            <label class="form-field">
              <span>Status *</span>
              <select name="status" data-status-select required>
                <option value="online" data-default-label="Online">Online</option>
                <option value="busy" data-default-label="Workshop">Workshop</option>
                <option value="offline" data-default-label="Offline">Offline</option>
              </select>
            </label>

            <label class="form-field">
              <span>Status label</span>
              <input
                type="text"
                name="status-label"
                placeholder="Defaults to the selected status"
                data-status-label-input
              />
            </label>

            <label class="form-field form-field-wide">
              <span>Description *</span>
              <textarea
                name="description"
                rows="3"
                placeholder="What makes this streamer unique?"
                required
              ></textarea>
            </label>

            <label class="form-field form-field-wide">
              <span>Languages *</span>
              <input
                type="text"
                name="languages"
                placeholder="Example: English, Japanese"
                required
              />
            </label>
          </div>

          <fieldset class="platform-fieldset">
            <legend>Streaming platforms *</legend>
            <p class="submit-streamer-help">
              Add each platform&rsquo;s name along with the regular channel URL and live stream URL.
              If they&rsquo;re the same, repeat the link in both fields.
            </p>
            <div class="platform-rows" data-platform-rows></div>
            <button type="button" class="add-platform-button" data-add-platform>
              + Add another platform
            </button>
          </fieldset>

          <label class="form-field form-field-wide">
            <span>GitHub token *</span>
            <input
              type="password"
              name="github-token"
              placeholder="Fine-grained or classic token with repo write access"
              required
            />
          </label>

          <div class="submit-streamer-actions">
            <button type="submit" class="submit-streamer-submit">Create pull request</button>
            <button type="button" class="submit-streamer-cancel" data-submit-cancel>
              Cancel
            </button>
          </div>

          <div
            id="submit-streamer-result"
            class="submit-streamer-result"
            role="status"
            aria-live="polite"
          ></div>
        </form>
      </section>
    </main>

    <footer>
      <span>&copy; <span id="current-year"></span> Sharpen Live. All rights reserved.</span>
      <span>
        Interested in the roster?
        <a href="mailto:partners@sharpen.live">partners@sharpen.live</a>
      </span>
    </footer>

    <script>
      const currentYearElement = document.getElementById("current-year");
      if (currentYearElement) {
        currentYearElement.textContent = new Date().getFullYear();
      }

      const tableBody = document.getElementById("streamers-table-body");
      const STATUS_CLASS_FALLBACK = "offline";
      const STATUS_LABEL_FALLBACK = "Offline";

      const createStatusCell = (streamer) => {
        const statusCell = document.createElement("td");
        statusCell.dataset.label = "Status";

        const span = document.createElement("span");
        const state = (streamer.status || STATUS_CLASS_FALLBACK).toLowerCase();
        span.className = `status ${state}`;
        span.textContent = streamer.statusLabel || STATUS_LABEL_FALLBACK;

        statusCell.appendChild(span);
        return statusCell;
      };

      const createNameCell = (streamer) => {
        const nameCell = document.createElement("td");
        nameCell.dataset.label = "Name";

        const strong = document.createElement("strong");
        strong.textContent = streamer.name;
        nameCell.appendChild(strong);

        if (streamer.description) {
          const description = document.createElement("div");
          description.className = "streamer-description";
          description.textContent = streamer.description;
          nameCell.appendChild(description);
        }

        return nameCell;
      };

      const createPlatformCell = (streamer) => {
        const platformCell = document.createElement("td");
        platformCell.dataset.label = "Streaming Platforms";

        const platforms = Array.isArray(streamer.platforms) ? streamer.platforms : [];
        if (!platforms.length) {
          platformCell.textContent = "—";
          return platformCell;
        }

        const list = document.createElement("ul");
        list.className = "platform-list";

        const state = (streamer.status || STATUS_CLASS_FALLBACK).toLowerCase();
        const isLive = state === "online";

        platforms.forEach((platform) => {
          const listItem = document.createElement("li");
          const link = document.createElement("a");
          link.className = "platform-link";
          link.textContent = platform.name;

          const liveUrl = platform.liveUrl || platform.channelUrl;
          const channelUrl = platform.channelUrl || platform.liveUrl;
          const targetUrl = isLive ? liveUrl : channelUrl;

          if (targetUrl) {
            link.href = targetUrl;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
          } else {
            link.setAttribute("aria-disabled", "true");
            link.tabIndex = -1;
          }

          listItem.appendChild(link);
          list.appendChild(listItem);
        });

        platformCell.appendChild(list);
        return platformCell;
      };

      const createLanguageCell = (streamer) => {
        const languageCell = document.createElement("td");
        languageCell.dataset.label = "Language";

        const languages = Array.isArray(streamer.languages)
          ? streamer.languages.join(" · ")
          : streamer.languages || "—";

        const span = document.createElement("span");
        span.className = "lang";
        span.textContent = languages;
        languageCell.appendChild(span);

        return languageCell;
      };

      const renderStreamerRow = (streamer) => {
        const row = document.createElement("tr");
        row.appendChild(createStatusCell(streamer));
        row.appendChild(createNameCell(streamer));
        row.appendChild(createPlatformCell(streamer));
        row.appendChild(createLanguageCell(streamer));
        return row;
      };

      const renderStreamers = (streamers) => {
        if (!tableBody) {
          return;
        }

        tableBody.innerHTML = "";

        if (!Array.isArray(streamers) || !streamers.length) {
          const emptyStateRow = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 4;
          cell.textContent = "No streamers available at the moment.";
          emptyStateRow.appendChild(cell);
          tableBody.appendChild(emptyStateRow);
          return;
        }

        streamers.forEach((streamer) => {
          tableBody.appendChild(renderStreamerRow(streamer));
        });
      };

      const loadStreamers = async () => {
        if (!tableBody) {
          return;
        }

        try {
          const response = await fetch("streamers.json", { cache: "no-cache" });
          if (!response.ok) {
            throw new Error(`Unexpected response: ${response.status}`);
          }
          const streamers = await response.json();
          renderStreamers(streamers);
        } catch (error) {
          console.error("Failed to load streamer roster", error);
          const errorRow = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 4;
          cell.textContent = "Unable to load streamers right now. Please try again later.";
          errorRow.appendChild(cell);
          tableBody.innerHTML = "";
          tableBody.appendChild(errorRow);
        }
      };

      const repoConfig = {
        owner: "Its-donkey",
        repo: "Sharpen-live",
        defaultBranch: "main",
      };

      const STATUS_DEFAULT_LABELS = {
        online: "Online",
        busy: "Workshop",
        offline: "Offline",
      };

      const decodeBase64 = (base64) => {
        const binary = atob(base64.replace(/\n/g, ""));
        const bytes = Uint8Array.from(binary, (char) => char.charCodeAt(0));
        return new TextDecoder().decode(bytes);
      };

      const encodeBase64 = (text) => {
        const bytes = new TextEncoder().encode(text);
        let binary = "";
        bytes.forEach((byte) => {
          binary += String.fromCharCode(byte);
        });
        return btoa(binary);
      };

      const slugify = (value, fallback = "streamer") => {
        if (!value) {
          return fallback;
        }
        const slug = value
          .toLowerCase()
          .trim()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "")
          .slice(0, 50);
        return slug || fallback;
      };

      const githubRequest = async (endpoint, token, options = {}) => {
        const url = `https://api.github.com${endpoint}`;
        const headers = {
          Accept: "application/vnd.github+json",
          Authorization: `Bearer ${token}`,
          ...(options.headers || {}),
        };
        const requestBody = options.body;
        const hasContentTypeHeader =
          Object.prototype.hasOwnProperty.call(headers, "Content-Type") ||
          Object.prototype.hasOwnProperty.call(headers, "content-type");
        const isFormData =
          typeof FormData !== "undefined" && requestBody instanceof FormData;

        if (requestBody && !hasContentTypeHeader && !isFormData) {
          headers["Content-Type"] = "application/json";
        }

        const response = await fetch(url, { ...options, headers });
        const contentType = response.headers.get("content-type") || "";
        const isJson = contentType.includes("application/json");
        const body = isJson ? await response.json() : await response.text();

        if (!response.ok) {
          const message =
            (isJson && body && body.message) ||
            `GitHub request failed (${response.status} ${response.statusText})`;
          const error = new Error(message);
          error.status = response.status;
          error.body = body;
          throw error;
        }

        return body;
      };

      const createBranch = async (branchName, baseSha, token) => {
        return githubRequest(
          `/repos/${repoConfig.owner}/${repoConfig.repo}/git/refs`,
          token,
          {
            method: "POST",
            body: JSON.stringify({
              ref: `refs/heads/${branchName}`,
              sha: baseSha,
            }),
          }
        );
      };

      const ensureBranch = async (baseSha, token, desiredName) => {
        let branchName = desiredName;
        let attempt = 0;

        while (attempt < 5) {
          try {
            await createBranch(branchName, baseSha, token);
            return branchName;
          } catch (error) {
            if (error.status === 422) {
              attempt += 1;
              branchName = `${desiredName}-${Date.now().toString(36)}`;
              continue;
            }
            throw error;
          }
        }

        throw new Error("Unable to create a unique branch for the submission.");
      };

      const buildStreamerEntry = (submission) => ({
        name: submission.name,
        description: submission.description,
        status: submission.status,
        statusLabel:
          submission.statusLabel ||
          STATUS_DEFAULT_LABELS[submission.status] ||
          STATUS_LABEL_FALLBACK,
        languages: submission.languages,
        platforms: submission.platforms,
      });

      const createStreamerPullRequest = async (submission, token) => {
        const baseRef = await githubRequest(
          `/repos/${repoConfig.owner}/${repoConfig.repo}/git/ref/heads/${repoConfig.defaultBranch}`,
          token
        );
        const baseSha = baseRef?.object?.sha;

        if (!baseSha) {
          throw new Error("Unable to locate the base branch SHA.");
        }

        const branchSlug = slugify(submission.name, "new-streamer");
        const branchName = await ensureBranch(
          baseSha,
          token,
          `feature/items/add-${branchSlug}`
        );

        const fileResponse = await githubRequest(
          `/repos/${repoConfig.owner}/${repoConfig.repo}/contents/web/streamers.json?ref=${repoConfig.defaultBranch}`,
          token
        );

        const existingContent = decodeBase64(fileResponse.content);
        let streamers;
        try {
          streamers = JSON.parse(existingContent);
        } catch (error) {
          throw new Error("Existing streamer list is not valid JSON.");
        }

        const newEntry = buildStreamerEntry(submission);
        streamers.push(newEntry);
        const updatedContent = `${JSON.stringify(streamers, null, 2)}\n`;

        await githubRequest(
          `/repos/${repoConfig.owner}/${repoConfig.repo}/contents/web/streamers.json`,
          token,
          {
            method: "PUT",
            body: JSON.stringify({
              message: `feat (items): add streamer ${submission.name}`,
              content: encodeBase64(updatedContent),
              branch: branchName,
              sha: fileResponse.sha,
            }),
          }
        );

        const prBody = [
          "## Summary",
          `- add **${submission.name}** to the Sharpen Live roster`,
          "",
          "## Generated By",
          "- Sharpen Live submission form",
        ].join("\n");

        const pullRequest = await githubRequest(
          `/repos/${repoConfig.owner}/${repoConfig.repo}/pulls`,
          token,
          {
            method: "POST",
            body: JSON.stringify({
              title: `feat: add streamer ${submission.name}`,
              head: branchName,
              base: repoConfig.defaultBranch,
              body: prBody,
            }),
          }
        );

        if (!pullRequest?.html_url) {
          throw new Error("Pull request was created, but no URL was returned.");
        }

        return pullRequest.html_url;
      };

      const initSubmitStreamerForm = () => {
        const form = document.querySelector("[data-streamer-form]");
        const toggleButton = document.querySelector("[data-submit-streamer-toggle]");
        const cancelButton = document.querySelector("[data-submit-cancel]");
        const platformRowsContainer = form?.querySelector("[data-platform-rows]");
        const addPlatformButton = form?.querySelector("[data-add-platform]");
        const resultElement = document.getElementById("submit-streamer-result");
        const statusSelect = form?.querySelector("[data-status-select]");
        const statusLabelInput = form?.querySelector("[data-status-label-input]");

        if (!form || !platformRowsContainer || !addPlatformButton) {
          return;
        }

        const setResult = (message, type = "info", { isHtml = false } = {}) => {
          if (!resultElement) {
            return;
          }
          if (isHtml) {
            resultElement.innerHTML = message;
          } else {
            resultElement.textContent = message;
          }
          resultElement.dataset.state = type;
        };

        const resetResult = () => setResult("");

        const syncStatusLabelWithDefault = ({ force = false } = {}) => {
          if (!statusSelect || !statusLabelInput) {
            return;
          }

          const defaultLabel =
            statusSelect.selectedOptions[0]?.dataset.defaultLabel ||
            STATUS_DEFAULT_LABELS[statusSelect.value] ||
            "";

          if (force || !statusLabelInput.dataset.userEdited) {
            statusLabelInput.value = defaultLabel;
          }
        };

        if (statusSelect && statusLabelInput) {
          syncStatusLabelWithDefault({ force: true });
          statusSelect.addEventListener("change", () => syncStatusLabelWithDefault());
          statusLabelInput.addEventListener("input", () => {
            statusLabelInput.dataset.userEdited = statusLabelInput.value.trim() ? "true" : "";
          });
        }

        const createInput = (labelText, options) => {
          const wrapper = document.createElement("label");
          wrapper.className = "form-field form-field-inline";

          const span = document.createElement("span");
          span.textContent = labelText;
          wrapper.appendChild(span);

          const input = document.createElement("input");
          Object.assign(input, options);
          input.required = true;
          wrapper.appendChild(input);

          return { wrapper, input };
        };

        const addPlatformRow = (prefill = {}) => {
          const row = document.createElement("div");
          row.className = "platform-row";
          row.dataset.platformRow = "true";

          const nameField = createInput("Platform name", {
            type: "text",
            name: "platform-name",
            value: prefill.name || "",
          });

          const channelField = createInput("Channel URL", {
            type: "url",
            name: "platform-channel",
            placeholder: "https://",
            value: prefill.channelUrl || "",
          });

          const liveField = createInput("Live stream URL", {
            type: "url",
            name: "platform-live",
            placeholder: "https://",
            value: prefill.liveUrl || "",
          });

          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.className = "remove-platform-button";
          removeButton.textContent = "Remove";
          removeButton.dataset.removePlatform = "true";

          row.appendChild(nameField.wrapper);
          row.appendChild(channelField.wrapper);
          row.appendChild(liveField.wrapper);
          row.appendChild(removeButton);

          platformRowsContainer.appendChild(row);
          return row;
        };

        const resetPlatformRows = () => {
          platformRowsContainer.innerHTML = "";
          addPlatformRow();
        };

        resetPlatformRows();

        addPlatformButton.addEventListener("click", () => {
          addPlatformRow();
        });

        platformRowsContainer.addEventListener("click", (event) => {
          const target = event.target;
          if (
            target instanceof HTMLElement &&
            target.dataset.removePlatform === "true"
          ) {
            const rows = Array.from(
              platformRowsContainer.querySelectorAll("[data-platform-row]")
            );

            if (rows.length <= 1) {
              rows[0].querySelectorAll("input").forEach((input) => {
                input.value = "";
              });
              return;
            }

            target.closest("[data-platform-row]")?.remove();
          }
        });

        const openForm = () => {
          form.hidden = false;
          form.scrollIntoView({ behavior: "smooth", block: "start" });
          toggleButton?.setAttribute("aria-expanded", "true");
        };

        const closeForm = () => {
          form.hidden = true;
          form.reset();
          resetPlatformRows();
          resetResult();
          toggleButton?.setAttribute("aria-expanded", "false");
          if (statusLabelInput) {
            delete statusLabelInput.dataset.userEdited;
          }
          syncStatusLabelWithDefault({ force: true });
        };

        toggleButton?.addEventListener("click", () => {
          if (form.hidden) {
            openForm();
          } else {
            closeForm();
          }
        });

        cancelButton?.addEventListener("click", () => {
          closeForm();
        });

        const collectPlatforms = () => {
          const rows = Array.from(
            platformRowsContainer.querySelectorAll("[data-platform-row]")
          );

          const platforms = rows
            .map((row) => {
              const inputs = row.querySelectorAll("input");
              const [nameInput, channelInput, liveInput] = inputs;
              const name = nameInput?.value.trim();
              const channelUrl = channelInput?.value.trim();
              const liveUrl = liveInput?.value.trim();

              if (!name || !channelUrl || !liveUrl) {
                return null;
              }

              return {
                name,
                channelUrl,
                liveUrl,
              };
            })
            .filter(Boolean);

          if (!platforms.length) {
            throw new Error("Please provide at least one platform with valid URLs.");
          }

          return platforms;
        };

        const collectSubmission = () => {
          const formData = new FormData(form);
          const name = (formData.get("streamer-name") || "").toString().trim();
          const description = (formData.get("description") || "").toString().trim();
          const status = (formData.get("status") || "").toString().trim().toLowerCase();
          const statusLabel = (formData.get("status-label") || "").toString().trim();
          const languagesRaw = (formData.get("languages") || "").toString();
          const token = (formData.get("github-token") || "").toString().trim();

          if (!name || !description || !status || !languagesRaw || !token) {
            throw new Error("Please complete all required fields before submitting.");
          }

          const languages = languagesRaw
            .split(",")
            .map((language) => language.trim())
            .filter(Boolean);

          if (!languages.length) {
            throw new Error("Please provide at least one language.");
          }

          const platforms = collectPlatforms();

          return {
            name,
            description,
            status,
            statusLabel,
            languages,
            platforms,
            token,
          };
        };

        form.addEventListener("submit", async (event) => {
          event.preventDefault();
          resetResult();

          const submitButton = form.querySelector(".submit-streamer-submit");
          submitButton?.setAttribute("disabled", "true");
          form.classList.add("is-submitting");

          try {
            const submission = collectSubmission();
            setResult("Creating pull request…", "pending");
            const prUrl = await createStreamerPullRequest(submission, submission.token);
            delete submission.token;
            setResult(
              `Pull request created: <a href="${prUrl}" target="_blank" rel="noopener noreferrer">${prUrl}</a>`,
              "success",
              { isHtml: true }
            );
            console.info("Streamer submission PR created:", prUrl);
            form.reset();
            resetPlatformRows();
            if (statusLabelInput) {
              delete statusLabelInput.dataset.userEdited;
            }
            syncStatusLabelWithDefault({ force: true });
          } catch (error) {
            console.error("Streamer submission failed", error);
            const message =
              error?.message || "Something went wrong while creating the pull request.";
            setResult(message, "error");
          } finally {
            submitButton?.removeAttribute("disabled");
            form.classList.remove("is-submitting");
          }
        });
      };

      loadStreamers();
      initSubmitStreamerForm();
    </script>
  </body>
</html>
